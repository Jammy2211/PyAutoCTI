Hi James,

Thanks for writing an ACS wrapper. An example ACS data file is
https://www.dropbox.com/s/4smmwgq4id6fi88/j8xi61meq_raw.fits?dl=0
which I’ve corrected using IDL code at
https://www.dropbox.com/s/f1pk620smhzlrq9/j8xi61meq_cte.fits?dl=0

I’ve attached an IDL routine that splits the quadrants and converts them to units of electrons (acs_split.pro - the
main routine is toward the end of the file) and another IDL routine that calculates trap parameters (acs_trap_species.pro,
which the C++ code also does, perhaps more cleanly). I’ve also described all the steps below.

Cheers,
Richard


Where are the quadrants?
An ACS/ACS fits file contains 6 arrays (I’m not sure how you select which one is to be read in python), and
7 headers (one main header, plus one header for each image). Arrays 4 and 1 are the pixel data for CCD1
(quadrants C and D) and CCD2 (quadrants B and A).
Arrays 2, 3, 5 and 6 are noise estimates and data quality flags - you don’t need to touch those.
If you want to check you have an ACS image, the main header should contain
TELESCOP= 'ACS'                / telescope used to acquire data
INSTRUME= 'ACS   '             / identifier for instrument used to acquire data


Size/orientation of the quadrants
Both image arrays contain 2 quadrants, and have the same number of pixels/orientation. See diagram in attached photo
or https://acs-docs.stsci.edu/acsihb/chapter-4-detector-performance/4-2-the-ccds#id-4.2TheCCDs-4.2.54.2.5CCDReadoutFormat
If you look at an image array, the parallel CTI trails make things obvious.
You can hardcode the layout of the pixels, as it has alwys been the same - but if you insist, it is specified in the
header for each array as
NAXIS   =                    2 / number of data axes
NAXIS1  =                 4144 / length of first data axis
NAXIS2  =                 2068 / length of second data axis
CENTERA1=                 2073 / subarray axis1 center pt in unbinned dect. pix
CENTERA2=                 1035 / subarray axis2 center pt in unbinned dect. pix
SIZAXIS1=                 4144 / subarray axis1 size in unbinned detector pixels
SIZAXIS2=                 2068 / subarray axis2 size in unbinned detector pixels
BINAXIS1=                    1 / axis1 data bin size in unbinned detector pixels
BINAXIS2=                    1 / axis2 data bin size in unbinned detector pixels


Image units (part 1)
For compressibility, the images are linearly scaled. The header for each array has
BUNIT   = 'COUNTS            ' / brightness units
BSCALE  =                  1.0 / scale factor for array value to physical value
BZERO   =              32768.0 / physical value for an array value of zero
and the main header has
EXPTIME =           645.000000 / exposure duration (seconds)--calculated
You need to read in the image then calculate
  (image*BSCALE)+BZERO if BUNIT == ‘COUNTS’
or
  (image*EXPTIME*BSCALE)+BZERO if BUNIT == ‘CPS’


Image units (part 2)
The images are usually stored in units of ADU “counts” or sometimes counts per second (cps). We need to convert to
electrons, correct CTI, then convert back. Converting to electrons involves:
  (image*calibrated_gain)-bias
...where calibrated_gain comes from commanded bscale listed in the main header
CCDAMP  = 'ABCD'               / CCD Amplifier Readout Configuration
CCDGAIN =                  2.0 / commanded bscale of CCD
CCDOFSTA=                    1 / commanded CCD bias offset for amplifier A
CCDOFSTB=                    1 / commanded CCD bias offset for amplifier B
CCDOFSTC=                    1 / commanded CCD bias offset for amplifier C
CCDOFSTD=                    1 / commanded CCD bias offset for amplifier D
converted into a true bscale, which varies slightly between readout nodes, as listed in https://acs-docs.stsci.edu/acsihb/chapter-4-detector-performance/4-2-the-ccds#id-4.2TheCCDs-table4.1 (only 1.0 or 2.0 is ever commanded).
...and where the most appropriate bias exposure is listed in the main header as
BIASFILE= 'jref$2571633hj_bia.fits' / bias image file name
where the file can be dowloaded from https://acs-crds.stsci.edu/browse/2571633hj_bia.fits (there is even a command-line command to get the file, althgouh I haven’t figured it out)
(note this file also needs the BSCALE and BZERO treatment.
In my IDL script, I also coded options to use the overscan pixels to approximate the bias, but it never worked well as there are lots of individually bad pixels.
There is more information at https://acs-docs.stsci.edu/acsihb


Trap parameters
The main header contains
DATE-OBS= '2013-10-06'         / UT date of start of observation (yyyy-mm-dd)
TIME-OBS= '06:39:13'           / UT time of start of observation (hh:mm:ss)
from which you can work out the Modified Julian date. If you can get to that point, I can handle the rest. But what I’ll do is as follows

Before repair_date=2454968 the total trap density per pixel was growing as
  trap_initial_density_presm4 = 0.017845
  trap_growth_rate_presm4 = 3.5488e-4
  trap_density = trap_initial_density_presm4+trap_growth_rate_presm4 * ( date - launch_date )
After that, it grew as
  trap_initial_density_postsm4 = -0.246591 * 1.011
  trap_growth_rate_postsm4 = 0.000558980 * 1.011
  trap_density = trap_initial_density_postsm4 + trap_growth_rate_postsm4 * ( dates - launch_date )

The traps are split between three species, with summed density as above, and individual density in the ratio
[1.27,3.38,2.85] / sum([1.27,3.38,2.85])
I suspect the absolute values mean something, but I can’t remember exctly what.

The trap release times changed when the instrument temperature was cooled. Before temperature_date=2453920.0
  operating_temperature[warm]=273.15-77
after this date, it was cooled to
  operating_temperature[cold]=273.15-81
In units of pixels, the trap preease time is
  sm4_temperature=273.15-81           # K
  k=8.617343e-5                       # eV/K
  DeltaE=[0.31,0.34,0.44]             # eV
  trap_release_time = [0.74,7.7,37] * (operating_temperature / (273.15-81) ) * exp( DeltaE / (k * sm4_temperature * operating_temperature ) * ( operating_temperature - sm4_temperature) )


